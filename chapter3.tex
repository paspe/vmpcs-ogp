
\chapter{Design and Implementation}\label{ch:chapter3}

In this chapter we will firstly discuss the goals of this research. We will expand on the design philosophy and go in depth on the implementation.

\section{Goals}\label{sec:goals}

As far as we know, all works on \ac{VM} monitoring and security focus in kernel and \ac{OS} protection, malicious activity monitoring or extensive logging for replay and online or offline forensic purposes, or secure resource sharing among \ac{VM}s. All these solutions do not provide any protection for the actual files of the system, which can be maliciously accessed when the \ac{VM} has been compromised. \ac{VM} security is a very active research filed, that produces many solutions, each with different focus, but generally surrounding the malware protection realm. Many of these are referenced in~\cite{bauman2015survey}, an extensive survey on hypervisor-based solutions.

\par In this research, we will try to leverage the Xenâ€™s \ac{VMI} capabilities and create a mechanism to protect some critical files on a \ac{VM}. We want to create an alternate \ac{ACL} on the hypervisor, that will include modified permissions for file access. The hypervisor will monitor what files are being accessed and cross-check the action with the \ac{ACL}s entries, enforcing the out-of-guest \ac{ACL}. Although a similar approach was employed with Paladin~\cite{baliga2008automated}, and integrity is improved in~\cite{nasab2012security}, there are some fundamental differences. 

\par We will focus on the use of type-I hypervisor instead of type-II. Moreover, we want the guest \ac{OS} to be unmodified and without any code, app or monitor injection that must be protected. We will employ the stealthy property of DRAKVUF~\cite{lengyel2014drakvuf}, to make the process of file protection completely transparent to the guest \ac{OS}, retaining this way a zero-footprint monitor on the guest. DRAKVUF also helps in bridging the semantic gap between the hypervisor and the \ac{VM} with the use of a Rekall profile~\cite{rekall}, having this way access to selected kernel structures. Furthermore, we want to employ a per user \ac{ACL}, enforced on specific files or whole folders, sometimes not essential to the \ac{OS}. Essentially, we want to protect any type of data, regardless of the content. Confidentiality is enforced by denying even read access, while integrity by denying write. This mechanism must also extend to the root user, since our threat model assumes that the system is compromised. Finally, we will try to enforce a specific file access mode, where log files are forced to open always in append mode rather than write, regardless of the program, process or user accessing them. To achieve all that we will intercept all relevant system calls and verify the validity of the request. 

