\acresetall
\newcommand\tab[1][1cm]{\hspace*{#1}}
\chapter{Design and Implementation of Ferify}\label{ch:chapter3}

In this chapter we will discuss the design, including the threat model and assumptions made, and the implementation choices that we made for this research.	

\section{Overview}\label{sec:overview}

\par In this research, we extend the Xen hypervisor by leveraging its \ac{VMI} capabilities to create a system which we call \codeft{ferify} that protects some critical files on a \ac{VM}'s mounted filesystem by intercepting and monitoring \emph{all} systems calls that may operate on these files. \codeft{ferify} maintains its own file \acp{ACL} and allows a system call to read or write a file \emph{if and only if} the \ac{ACL} permits the action explicitly for the \ac{UID} and \ac{GID} combination of the calling process. We call this \ac{ACL} the \ac{SACL}, to differentiate it from other \acp{ACL} configured on guest \acp{VM}. It is important to note that the content of \ac{SACL} cannot be read or modified by \emph{any} process including kernel processes from a guest \ac{VM}. The above permissions can be different compared to those on the guest \ac{VM}, allowing for the enforcement of different file access policy than the ones enforced by the guest \ac{VM}, even while under \ac{VM} compromised attacks. The \ac{ACL} policy enforced by the guest \ac{OS} remains active, meaning that if for some reason the \ac{SACL} entry allows file access but the guest \ac{OS} \ac{ACL} does not, the file will not be accessed.

\par Before presenting the design and implementation details, we first briefly discuss why our solution is secure. We chose to monitor which files are being accessed by trapping on the system calls that are being invoked. 

\par As mentioned in \cite{linuxkernel}, a User Mode process cannot access directly the hardware. Each file operation must be performed in Kernel Mode. The \ac{OS} will not allow direct access to hardware. If a process needs file access, it needs to perform a system call, asking this way the \ac{OS} for the desired operation. The \ac{OS} checks if the request is valid and if it is the \ac{OS} accesses the file on behalf of the process and returns to the process the result of the operations, as shown in \ref{fig:syscall}. This requirement, to make a system call for \emph{all} file operations, provides the place in the \ac{OS} executable code, which if we monitor we can extract the information of all files being accessed. So, we cannot miss \emph{any file any process} will try to open.

\begin{figure}[ht]
	\centering
	\input{figs/syscalls.tikz}
	\caption{System call information flow}
	\label{fig:syscall}
\end{figure}

\par Table 12.1 in \cite{linuxkernel} shows the list of system calls relevant to filesystems. According to that table, the system calls of importance to us are \codeft{open()}, \codeft{rename()}, \codeft{link()}, \codeft{symlink()}, \codeft{unlink()}, and \codeft{truncate()}. Some of these system calls have been evolved over time to provide better security and to eliminate problems. Such an evolved system call is \codeft{openat()}. Going through the available system call list in \codeft{/usr/include/asm/unistd\_64.h}, we assess that the system calls mentioned in table~\ref{tbl:syscalls}, where number is the system call number as it is passed to the kernel, provide \emph{full coverage} of the possible ways a file can be accessed when being on a mounted device. 

\par As explained in \cite{perla2010guide}, it is possible for an attacker to modify the credentials of a process after acquiring \codeft{root} privileges. This exploit is a significant security issue for \codeft{ferify}, since it collects the \ac{UID} and \ac{GID} of the running process from the \ac{VM}'s kernel memory. To avoid the success of such an exploit, \codeft{ferify} monitors the credentials of \emph{all} running processes inside the guest \ac{VM}, and additionally monitors the creation of new processes to record their credentials as well. Then, according to preset rules \codeft{ferify} decides whether a change in the credentials of a process is allowed or not, and acts accordingly. This way we secure the validity of the information we collect from the guest \ac{VM}.


\begin{table}[ht]
	\centering
	\caption{Trapped system calls related to file operations}
	\label{tbl:syscalls}
	\begin{tabular}{cc|cc}
		\toprule
		\textbf{System call} & \textbf{Number} & \textbf{System call} & \textbf{Number} \\
		\hline
		\footnotesize{\fontfamily{qcr}\selectfont open()} 					
		& \footnotesize{\fontfamily{qcr}\selectfont 2} & 
		\footnotesize{\fontfamily{qcr}\selectfont openat()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 257} \\ 
		\footnotesize{\fontfamily{qcr}\selectfont name\_to\_handle\_at()} 	
		& \footnotesize{\fontfamily{qcr}\selectfont 303} &
		\footnotesize{\fontfamily{qcr}\selectfont open\_by\_handle\_at()} 	
		& \footnotesize{\fontfamily{qcr}\selectfont 304} \\
		\footnotesize{\fontfamily{qcr}\selectfont rename()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 82} & 
		\footnotesize{\fontfamily{qcr}\selectfont renameat()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 264} \\  
		\footnotesize{\fontfamily{qcr}\selectfont renameat2()} 			
		& \footnotesize{\fontfamily{qcr}\selectfont 316} & 
		\footnotesize{\fontfamily{qcr}\selectfont truncate()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 76} \\
		\footnotesize{\fontfamily{qcr}\selectfont link()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 86} &
		\footnotesize{\fontfamily{qcr}\selectfont linkat()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 265} \\
		\footnotesize{\fontfamily{qcr}\selectfont symlink()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 88} &
		\footnotesize{\fontfamily{qcr}\selectfont symlinkat()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 266} \\
		\footnotesize{\fontfamily{qcr}\selectfont unlink()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 87} &
		\footnotesize{\fontfamily{qcr}\selectfont unlinkat()} 				
		& \footnotesize{\fontfamily{qcr}\selectfont 263} \\
		\bottomrule
	\end{tabular}	
\end{table}

\par LibVMI, and therefore DRAKVUF, needs for the guest \ac{VM} to have reached a state, after launching, to be able to start monitoring the guest \ac{VM}. After we launch a VM there might be a small time window when the guest \ac{VM} is running without the protection of our system. Until we find a way to find the exact time LibVMI can be initialized to protect the guest \ac{VM}, we will consider attacks that modify the running system during boot-time outside the scope of this research. To prevent the system from being attacked during that small time-frame, we do not connect the \ac{VM} to the network until this initialization process is completed. 

\section{Threat Model}\label{sec:threat}

Computer security has been evolving because the attackers methods evolve, too. Modern \acp{OS} and applications are so complex that they introduce many bugs in their code. Some of these bugs are benign, but some are serious enough to allow security breaches like remote access to a system, administrator/root access, and arbitrary code execution.

\par For this research, we have adopted a \emph{moderate} threat model where we assume that the guest \ac{VM} is insecure. We assume that physical access to the hosting machine is restricted and the attacker cannot use physical media like USB sticks or CD-ROMs to compromise the host system. The protected files are only remotely accessible and protected  by  a  public-key  authentication  and  encryption scheme (i.e.,\emph{SSH}). The  private  keys  of  authorized  users  are  secure, while the attacker may have obtained \emph{root} privileges on the \ac{VM} through a successful attack. Assuming that the target \ac{VM} will be accessible only remotely, reflects many applications and systems working over a network connection as well as cloud solutions. A significant  concern  in  computer security is that of replay attacks. Even if a legitimate user connects using \emph{SSH}, there are attacks that can monitor  network  traffic  on  the  host  and  steal  sensitive data after they are decrypted. We consider this type of attacks and how to mitigate them orthogonal to this research, as the \emph{SSH} protocol is widely used and evolving.Finally, The files we want to protect are on a mounted disk.

\par Moreover, we assume that the \ac{OS} installed on the guest \ac{VM} is not trusted. This essentially means that the adversaries can gain root privileges, allowing them this way to modify system executables, as well as load kernel modules during runtime. This allows for kernel memory modification.

\par We consider the hypervisor along with its Dom0 to be secure and trusted; hypervisor vectored attacks or how to protect the hypervisor is outside the scope of this research.

\section{Requirements}\label{sec:requirements}
The goal of this research is to provide a virtualization extension that will extend the granular-level file access control of the Linux \ac{OS}. The requirements we defined for our system are:
\begin{itemize}
	\item \textbf{(R1)} The solution must be \emph{out-\ac{VM}}, to avoid modification from the potential adversary. 
	\item \textbf{(R2)} The system must remain \emph{efficient and usable}, by not introducing significant overhead on the runtime of the \ac{VM}, as well as by not enforcing many restrictions to the users. 
	\item \textbf{(R3)} \emph{All} relevant system calls must be monitored.
\end{itemize}


\section{Design}\label{sec:design}

\par We used a type-I hypervisor instead of type-II, as type-I hypervisors are more efficient and deployed more as a commercial solution, while type-II are used mostly for testing and analysis. We chose the Xen hypervisor as it is open-source and is used widely, so the results of the research can be used in a variety of applications. By leveraging Xen's introspection methods, we created an \emph{Out-VM} monitoring agent, which runs on Dom0, completely \emph{outside} the \ac{VM}, conforming this way with \textbf{(R1)}. Also, by ensuring that there is no code running on the guest \ac{OS}, we increased the deployment speed, as there is no need to modify the guest \ac{VM} in any way. The required pre-deployment configuration for the guest \ac{VM} is kept to a minimum and does not involve any modification, only information gathering.

\par As a platform to base our solution, we chose DRAKVUF~\cite{lengyel2014drakvuf}. DRAKVUF provided us a stealthy monitoring base, as it leverages alternate \ac{EPT}s with different permissions, preventing any detection from applications inside a \ac{VM}. We had to restrict some of the usability of the system, although not during normal execution, to achieve the file \emph{confidentiality}, \emph{integrity} and \emph{availability} we wanted, as explained later in this chapter. Therefore we assumed that \textbf{(R2)} is achieved in the part of restrictions, although a few restrictions apply, mostly concerning the \codeft{root} user. Overhead and usability of the system will be discussed in chapter \ref{ch:chapter4}.

\par We employed the stealthy property of DRAKVUF to make the process of file protection \emph{completely transparent} to the guest \ac{OS}, retaining a \emph{zero-footprint} monitor on the guest. DRAKVUF also helped bridge the semantic gap between the hypervisor and the \ac{VM} with the use of a Rekall profile~\cite{rekall}, by having access to selected kernel structures. Furthermore, we wanted to employ a per-user \ac{ACL}, enforced on specific files or whole folders, which are sometimes not essential to the \ac{OS}, but \emph{essential to the user}. Generally, we wanted to protect any type of data, regardless of the content. We improved \emph{confidentiality} by denying even read access, \emph{integrity} by denying write, and \emph{availability} by protecting deletion or moving of the files. This mechanism must also extend to the \codeft{root} user, since our threat model assumed that the system is compromised. To achieve that, we intercepted \emph{all} relevant system calls from \emph{all} users and verify the validity of the request. 

\par Monitoring the execution of the system calls in table \ref{tbl:syscalls} and validating the request made to the guest \ac{OS} kernel is sufficient for ensuring the guest \ac{VM} file confidentiality, integrity and availability, as we want to enforce it, thus conforming to \textbf{(R3)}.


\section{Implementation}\label{sec:implementation}

\par Following we expand on how we implemented the mechanism to provide the file access security of our system.

\subsection{Architecture}\label{sub:arch}

\par \codeft{erify} was developed as a plugin for DRAKVUF. As such, it is a C++ class that extends the class \emph{plugin}, as per requirements of DRAKVUF. It is located in the directory \emph{src/plugins/ferify/} and consists of two files, \emph{ferify.h} and \emph{ferify.cpp}, as show in figure \ref{fig:dir_tree}. 

\begin{figure}[ht]
	\centering
	\input{figs/dir_tree.tikz}
	\caption{ferify directory tree}
	\label{fig:dir_tree}
\end{figure}

\subsection{Shadow Access Control List}\label{sub:sacl}
During the initialization of our DRAKVUF plugin, we read the \ac{SACL}s we had created for the \ac{VM} to be protected. The \ac{SACL} is implemented in the form of four hash-tables to improve search speed. Figure~\ref{fig:sacl_layout} depicts the structure created for storing each \ac{SACL} entry.

\begin{figure}[ht]
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Variable Name} & \textbf{Variable type} \\
		\hline
		\footnotesize{\fontfamily{qcr}\selectfont pathname} & 
		\footnotesize{\fontfamily{qcr}\selectfont char *} \\
		\hline
		\footnotesize{\fontfamily{qcr}\selectfont mode} & 
		\footnotesize{\fontfamily{qcr}\selectfont unsigned int} \\
		\hline
		\footnotesize{\fontfamily{qcr}\selectfont u} & 
		\footnotesize{\fontfamily{qcr}\selectfont uid\_t} \\
		\hline
		\footnotesize{\fontfamily{qcr}\selectfont g} & 
		\footnotesize{\fontfamily{qcr}\selectfont gid\_t} \\
		\hline
	\end{tabular}
	\caption{\textit{struct protected\_files} memory layout}
	\label{fig:sacl_layout}
\end{figure}

\par The above memory structure is used for both protected folders and protected files. Moreover, we create two of each; one for the \codeft{root} user and one for the rest. Searching in the \acp{SACL} is done with the pathname of the file being accessed as the hash-table key. The return value is a pointer to the structure of fig. \ref{fig:sacl_layout}. 

\par In the \ac{SACL} file permissions are set according to the Linux permission bits schema. This means that the last 3 digits of the \textit{mode} field, when encoded in octal form, define the permissions we want to enforce. The first one defines the owner permissions, the second the group permissions, and the third the other user permissions. The number itself is the sum of the permissions 4 for read, 2 for write, and 1 for execute. As an example, if we encounter or set permissions 744, it means that the owner can read, write and execute the file, while anyone in the same group and everyone else can only read the file.

\par The \ac{SACL}'s format was kept as simple as possible so that editing and reviewing it is easy. Additionally, by keeping the format of the Linux \ac{ACL}, we provide to the system administrator a familiar permissions schema, so it is easier to understand and manage. Figure~\ref{fig:sacl} shows an example, which we will analyze later.

\begin{figure}[ht]
	\centering
	\begin{lstlisting}
Pathname			Permissions	User	Group
	\end{lstlisting}
	\footnotesize{\fontfamily{qcr}\selectfont 
	\begin{lstlisting}
/home/user/Documents/readme.txt	100644		1000	1000
/home/user/Desktop/credit.pdf6	100400		1000	1000
/home/user/Documents		140220		0	0
	\end{lstlisting}}
	\caption{\ac{SACL} sample}
	\label{fig:sacl}
\end{figure}

\par The system keeps four \acp{SACL}: two for all non-root users and two for root, since this account is of greater significance. Furthermore, two different checks are being performed. First it checks for a protected folder, as it is a more generic case. If no entry is found, it then checks for specific files in the list to match. 

\par We chose to create two separate \acp{SACL} to improve the permissions policy of our solution. By making this separation we allow for the creation of separate permissions for normal users and the \codeft{root} user. It makes managing of different permissions easier. 
%the program to automatically eliminate entries in the \ac{SACL} that need not be checked against. If a program or service runs as root, we do not need to check the entries that apply to the rest of the users and vice versa. Additionally, since the root user account will always run on a system, because the \ac{OS} runs under this account, root will constantly open files relevant to the running of the \ac{OS}. Therefore, we assess that adding more entries to match against in the \ac{SACL} will introduce a performance overhead we can avoid with the separation we implemented. 
Besides this coarse refinement of the \ac{SACL} entries, the level of protection applied to the files is the same, whether applied to the root user or any other user.

\par As we see in figure~\ref{fig:root_sacl}, the \ac{SACL} for protecting files from the \codeft{root} user is more simple. Since it is targeted for this specific user, we do not need the entries for owner and group. Furthermore, the permission bits for group and others are ignored when parsed, since they are meaningless.

\begin{figure}[ht]
	\centering
	\begin{lstlisting}
	Pathname	Permissions	
	\end{lstlisting}
	\footnotesize{\fontfamily{qcr}\selectfont 
	\begin{lstlisting}
	/etc/shadow     100400
	/etc/pam.d/su   100000
	\end{lstlisting}}
	\caption{root user \ac{SACL} sample}
	\label{fig:root_sacl}
\end{figure}


\par Before moving on, we must emphasize that the system does not alter basic properties of the files that are being protected. It does not change the owner or the group, since this requires intervention in the \ac{VM}. Although in the \ac{SACL} we can define a different owner, the generic effects is denial of access. This means that we cannot change who can access a file, rather we can change who cannot. This system acts as a supplementary and more fine-grained access control mechanism to make more strict file access policies. Therefore, if we change the owner of a file in the \ac{SACL}, we essentially prohibit access to that file by the owner; we do not specify a new one, as the final call for file access comes from the unmodified guest \ac{OS}.



\subsection{System Call Interception and Admission Control}\label{sub:syscalls}


\par All applications running in user-space need to ask the kernel to access a file. Applications do not have knowledge of the low-level \ac{OS} and device details to access the files they need, so they request from the kernel to do that work for them. The kernel accesses the requested file using the device drivers and, when the operation is completed, returns to the application a handle to that file, called file descriptor. This happens for many operations restricted to the kernel for security reasons. Also, it provides an abstraction to the applications, which are written without the need of the knowledge of device specifics and work on variations of the underlying hardware running the same \ac{OS}. 

\par For applications to be compatible to \ac{OS} version upgrades and portable between different systems, a specific standard calling convention of these kernel functions is needed. This calling convention is a system call. System calls are specific entry points to the kernel, which, when provided specific arguments perform an operation on behalf of the application. Many system calls exist, each performing a different operation. We will focus on those who are relevant to accessing files, whether to read or modify. These are depicted in table~\ref{tbl:syscalls}.

\par To gain the insight on what files are being accessed, we need to know whenever this event happens. We will use DRAKVUF to create a trap on all the afore-mentioned system calls.

\par This gives us the opportunity to stop the \ac{VM} execution when these system calls are called. At this point, we access the registers related with each system call to retrieve the information we need to perform the validation of the requested call. Figure~\ref{fig:overview} gives an overview of the flow of information during a trapped system call. 

\par The arguments to the system calls for the 64-bit Linux \ac{OS} we used as our test platform are passed to the kernel through the registers in the order of rdi, rsi, rdx, r10, r8, r9, while the system call number is passed in rax. Table~\ref{tbl:prototypes} shows which arguments need to be passed to each system call on each register for it to perform the requested operation.

\begin{table}[ht]
	\centering
	\footnotesize
	\caption{Arguments of trapped system calls}
	\label{tbl:prototypes}			
	\begin{tabular}{ccccccc}
		\toprule
		\textbf{Syscall} &&&&&&\\
		\textbf{Name} & \textbf{rax} & \textbf{rdi} & \textbf{rsi} & \textbf{rdx} & \textbf{r10} & \textbf{r8}\\
		\toprule
		\scriptsize{\fontfamily{qcr}\selectfont open }					& 
		\scriptsize{\fontfamily{qcr}\selectfont 2} 						&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&	
		\scriptsize{\fontfamily{qcr}\selectfont int flags}				&
		\scriptsize{\fontfamily{qcr}\selectfont int mode}				&&\\
		&&	\scriptsize{\fontfamily{qcr}\selectfont *pathname}			&&&&\\
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont openat	}				& 
		\scriptsize{\fontfamily{qcr}\selectfont 257 } 					&	
		\scriptsize{\fontfamily{qcr}\selectfont int dirfd	}			&
		\scriptsize{\fontfamily{qcr}\selectfont const char }			&
		\scriptsize{\fontfamily{qcr}\selectfont int flags}				&
		\scriptsize{\fontfamily{qcr}\selectfont int mode}				&\\
		&&& \scriptsize{\fontfamily{qcr}\selectfont *pathname} 			&&&\\
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont name\_to\_handle\_at }	&
		\scriptsize{\fontfamily{qcr}\selectfont  303 }  				&	
		\scriptsize{\fontfamily{qcr}\selectfont int dirfd}				&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&	
		\scriptsize{\fontfamily{qcr}\selectfont struct}					&	
		\scriptsize{\fontfamily{qcr}\selectfont int}					&	
		\scriptsize{\fontfamily{qcr}\selectfont int}	 				\\
		&&&\scriptsize{\fontfamily{qcr}\selectfont *pathname}			& \scriptsize{\fontfamily{qcr}\selectfont file\_handle} 			&
		\scriptsize{\fontfamily{qcr}\selectfont mount\_id}				&
		\scriptsize{\fontfamily{qcr}\selectfont flags}					\\
		&&&&\scriptsize{\fontfamily{qcr}\selectfont *handle}			&&\\
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont open\_by\_handle\_at} 	& 
		\scriptsize{\fontfamily{qcr}\selectfont 304}  					&	
		\scriptsize{\fontfamily{qcr}\selectfont int mountfd}			&	
		\scriptsize{\fontfamily{qcr}\selectfont struct}					&	
		\scriptsize{\fontfamily{qcr}\selectfont int	flags}				&&\\
		&&& \scriptsize{\fontfamily{qcr}\selectfont file\_handle}		&&&\\
		&&&	\scriptsize{\fontfamily{qcr}\selectfont *handle}			&&&\\
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont rename} 				& 
		\scriptsize{\fontfamily{qcr}\selectfont 82}  					&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&&&\\
		&&	\scriptsize{\fontfamily{qcr}\selectfont *oldpath}			&	
		\scriptsize{\fontfamily{qcr}\selectfont *newpath}				&&&\\
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont renameat} 				& 
		\scriptsize{\fontfamily{qcr}\selectfont 264}  					&	
		\scriptsize{\fontfamily{qcr}\selectfont int} 					&	
		\scriptsize{\fontfamily{qcr}\selectfont const char} 			&	
		\scriptsize{\fontfamily{qcr}\selectfont int} 					&	
		\scriptsize{\fontfamily{qcr}\selectfont const char} 			&\\
		&&	\scriptsize{\fontfamily{qcr}\selectfont olddirfd}			&	
		\scriptsize{\fontfamily{qcr}\selectfont *oldpath}				&	
		\scriptsize{\fontfamily{qcr}\selectfont newdirfd}				&	
		\scriptsize{\fontfamily{qcr}\selectfont *newpath}				&\\ 
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont renameat2} 				& 
		\scriptsize{\fontfamily{qcr}\selectfont 316}  					&	\scriptsize{\fontfamily{qcr}\selectfont int}					&	\scriptsize{\fontfamily{qcr}\selectfont const char} 			&	\scriptsize{\fontfamily{qcr}\selectfont int} 					&		
		\scriptsize{\fontfamily{qcr}\selectfont const char} 			&	
		\scriptsize{\fontfamily{qcr}\selectfont unsigned}				\\
		&&	\scriptsize{\fontfamily{qcr}\selectfont olddirfd}			&	
		\scriptsize{\fontfamily{qcr}\selectfont *oldpath}				&	
		\scriptsize{\fontfamily{qcr}\selectfont newdirfd}				&	
		\scriptsize{\fontfamily{qcr}\selectfont *newpath}				& 	
		\scriptsize{\fontfamily{qcr}\selectfont int flags}				\\ 
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont link} 					& 
		\scriptsize{\fontfamily{qcr}\selectfont 86}  						&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&&&&\\
		&&	\scriptsize{\fontfamily{qcr}\selectfont *pathname}			&&&&\\ 
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont linkat} 				& 
		\scriptsize{\fontfamily{qcr}\selectfont 265}  						&	
		\scriptsize{\fontfamily{qcr}\selectfont int dirfd}				&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&	
		\scriptsize{\fontfamily{qcr}\selectfont int flag}				&&\\
		&&&	\scriptsize{\fontfamily{qcr}\selectfont *pathname}			&&&\\
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont symlink} 				& 
		\scriptsize{\fontfamily{qcr}\selectfont 88}  						&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&&&&\\
		&&	\scriptsize{\fontfamily{qcr}\selectfont *pathname}			&&&&\\ 
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont symlinkat} 				& 
		\scriptsize{\fontfamily{qcr}\selectfont 266}  						&	
		\scriptsize{\fontfamily{qcr}\selectfont int dirfd}				&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&	
		\scriptsize{\fontfamily{qcr}\selectfont int flag}				&&\\
		&&&	\scriptsize{\fontfamily{qcr}\selectfont *pathname}			&&&\\
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont unlink} 				& 
		\scriptsize{\fontfamily{qcr}\selectfont 87}  					&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&&&&\\
		&&	\scriptsize{\fontfamily{qcr}\selectfont *pathname}			&&&&\\ 
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont unlinkat} 				& 
		\scriptsize{\fontfamily{qcr}\selectfont 263}  					&	
		\scriptsize{\fontfamily{qcr}\selectfont int dirfd}				&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&	
		\scriptsize{\fontfamily{qcr}\selectfont int flag}				&&\\
		&&&	\scriptsize{\fontfamily{qcr}\selectfont *pathname}			&&&\\
		\hline
		\scriptsize{\fontfamily{qcr}\selectfont truncate} 				& 
		\scriptsize{\fontfamily{qcr}\selectfont 76}  					&	
		\scriptsize{\fontfamily{qcr}\selectfont const char}				&	
		\scriptsize{\fontfamily{qcr}\selectfont off\_t}					&	
		\scriptsize{\fontfamily{qcr}\selectfont int flag}				&&\\
		&&	\scriptsize{\fontfamily{qcr}\selectfont *pathname}			&	
		\scriptsize{\fontfamily{qcr}\selectfont length}					&&&\\
		\bottomrule
	\end{tabular}
\end{table}

\subsection{System Call Hooking}\label{sub:hooking}

To achieve the above mentioned system call intercept we need to place traps to the system calls of interest. This gets implemented by DRAKVUF. LibVMI reads the Rekall profile of the guest \ac{VM} to get the base address of the kernel symbol table. DRAKVUF then starts from that base address and searches for the system call table. This table includes the function pointers for all supported system calls. Going through that table makes possible the detection and trapping of the system calls. This is achieved by placing the \codeft{INT3 (0xCC)} byte at the beginning of the system call function. This byte is executed by the \ac{CPU} as a debugging interrupt, a breakpoint. This in its turn triggers a VM-exit, which is caught by DRAKVUF and handled by our callback function. DRAKVUF implements multiple \ac{EPT}s with different permissions for the same page. This allows placing the trap in the system calls, while at the same time when accessed for read, the original functions are accessed, not revealing this way the injected breakpoint.

\par Table~\ref{tbl:prototypes} shows that there are two generic cases we need to examine. One case is for the \codeft{open()}, \codeft{rename()}, \codeft{link()}, \codeft{symlink()}, \codeft{unlink()}, and \codeft{truncate()} system calls, where we have to find the string pointed by the pointer in the \codeft{rdi} register, and in the \codeft{rsi} register in the case of \codeft{rename()}. 

\par The second case is for the \codeft{openat()}, \codeft{renameat()}, \codeft{renameat2()}, \codeft{linkat()}, \codeft{symlinkat()}, and \codeft{unlinkat()} system calls, where we have to retrieve the string of the file being accessed from different registers, according to table~\ref{tbl:prototypes}. 

\begin{figure}[ht]
	\centering
	\input{figs/overview.tikz}
	\caption{Information flow during a trapped system call execution}
	\label{fig:overview}
\end{figure}


\subsection{The task struct}\label{sub:struct}
A crucial part in the design of our solution is the Linux kernel \codeft{task\_struct}. It a complex structure where the kernel stores many information concerning the running processes. Each running process is assigned one such structure by the kernel, so that the kernel can monitor the process and retrieve various information about it. A special macro, \codeft{current}, points directly to the current running process. We need to map this structure and find the address offsets of the information we need. We will revisit the \codeft{task\_struct} in the next sections, as we mention what we need to access.

\par Although normally this process is not complex, in our case there are some challenges, the semantic gap already mentioned for all out-\ac{VM} solutions. The first is that we need to find the correct offsets inside the \codeft{task\_struct} for the entries we want, which depend on the kernel version. Furthermore, we need to make constant conversions between \ac{GMFN} and \ac{MFN}, as the memory values we retrieve correspond to the \ac{VM}s address space, but we need to access the actual physical memory to read the information we require.


\subsection{Trap Handling}\label{sub:handling}

After a hooked system call gets executed, our callback function is called. We firstly retrieve the file that is being accessed and by which process, by getting its process id (figure~\ref{fig:getfile}). 

\begin{figure}[ht]
\footnotesize {
	{\fontfamily{qcr}\selectfont 
currpid = vmi\_dtb\_to\_pid(vmi, info->regs->cr3);\\
switch (info->regs->rax)\{\\
case S\_OPEN:\\
case S\_RENAME:\\
case S\_UNLINK:\\
\tab	addr=vmi\_translate\_uv2p(vmi,info->regs->rdi,currpid);\\
\tab	filename=vmi\_read\_str\_pa(vmi,addr);\\
\tab	.\\
\tab	.\\
\tab	break;\\
case S\_OPENAT:\\
case S\_UNLINKAT:\\
case S\_RENAMEAT:\\
case S\_RENAMEAT2:\\
\tab	addr=vmi\_translate\_uv2p(vmi,info->regs->rsi,currpid);\\
\tab	filename=vmi\_read\_str\_pa(vmi,addr);\\
\tab	.\\
\tab	.\\
\tab	break; \} \\
	}
}
	\caption{Getting the file being accessed}
	\label{fig:getfile}
\end{figure}


\par When a system call is executed the file being accessed is passed as a string pointer. After we retrieve the string, we check whether the file is given in the form of an absolute or relative path. If the path is absolute there is nothing more to do and the algorithm continues. If the path is relative, the retrieval procedure is more complicated. That is because we need to recreate the \ac{PWD}. The Linux kernel does not store this information somewhere. On the contrary, in the \codeft{task\_struct}, the kernel only stores in another structure only the parent directory. Therefore, we need to loop through the parent folders, so that by prepending each time the parent, we recreate the \ac{PWD} and the full pathname. To achieve this we created a new function that walks though the codeft{task\_struct} to collect all the required information. 

\par The case for the \codeft{openat()}, \codeft{renameat()}, \codeft{renameat2()}, \codeft{linkat()}, \codeft{symlinkat()}, and \codeft{unlinkat()} system calls is different. Among the arguments, there is one called \codeft{dirfd}. This argument is not always used. When it is not, the algorithm is the same as above. When it is used, it is in the form of a directory descriptor. This means that the process has already successfully opened a directory, and passed its descriptor as an argument, which represents the mount directory for the file. In this case we go though the \codeft{task\_struct} structure of the current running process and retrieve the directory that maps to the directory descriptor, so that we can recreate the pathname of the file.

\par After we have retrieved the pathname, we then check for the system call that triggered the VM-exit event. For this research we will not handle the \codeft{name\_to\_handle\_at()} and \codeft{open\_by\_handle\_at()} system calls. At this point of the research we are unaware of any compiled program that uses this specific system call. Support for them can be added in the future, while at the same time does not hinder our proof of concept. The rest of the system calls are handled as follows: 


\begin{itemize}
	\item \codeft{link()}, \codeft{linkat()}, \codeft{symlink()}, \codeft{symlinkat()}, \codeft{unlink()}, and \codeft{unlinkat()}
	\item \codeft{open()} and \codeft{openat()}
	\item \codeft{rename()}, \codeft{renameat()}, and \codeft{renameat2()}
\end{itemize}

\par In the first case, where the system calls are used for linking and file deletion the procedure is straightforward. Once we look in the \ac{SACL}, if there is an entry, we verify that the user or group accessing the file, has sufficient permissions. If that is true, the callback function returns control to the \ac{VM} to resume execution. If permissions do not match, the pointer to the filename string is modified to \codeft{NULL}, so that the system call, after the \ac{VM} resumes execution, fails (figure~\ref{fig:unlink}). By hooking and preventing execution of these system calls we prevent deletion and linking of the protected files, improving this way the availability and confidentiality assurances of the underlying \ac{OS}.

\begin{figure}[ht]
\footnotesize {
	{\fontfamily{qcr}\selectfont 
case S\_UNLINK:\\          
case S\_UNLINKAT:\\
\tab  switch(info->userid)\{\\
\tab \tab case ROOT: // root user\\
\tab \tab \tab 	if(strcmp(check->pathname,filename)==0)\{\\
\tab \tab \tab \tab 		check\_permissions(check,info,vmi,ROOT);\\			
\tab .\\
\tab .\\
\tab \tab \tab break;\\
\tab \tab default: // other users\\
\tab \tab \tab if (strcmp(check->pathname,filename)==0)\{\\
\tab \tab \tab \tab if (check->u == info->userid)\{\\
\tab \tab \tab \tab \tab check\_permissions(check,info,vmi,USER);\}\\
\tab \tab \tab \tab else if (check->g == info->groupid)\{\\
\tab \tab \tab \tab \tab check\_permissions(check,info,vmi,GROUP);\}\\
\tab \tab \tab else \{\\
\tab \tab \tab \tab check\_permissions(check,info,vmi,OTHER);\}\}\\
\tab .\\
\tab .\\
\tab \tab \tab break;\}}}
	\caption{unlink() and unlinkat() skeleton code flow}
	\label{fig:unlink}
\end{figure}

\par The search for a match in the \ac{SACL}s is performed in two steps for all cases. Once to go through protected folders and once to go through individually protected files. Also, the \codeft{root} user is handled separately from the rest of the users because of the special elevated privileges that account is granted. 

\par In the case of \codeft{rename()}, \codeft{renameat()} and \codeft{renameat2()}, which are used for file moving, we perform the same check as per \codeft{unlink()} and \codeft{unlinkat()}, with the difference that if we do not find a match for the \codeft{oldname} of the system call, we additionally check for a match on the \codeft{newname}. The first part ensures that if the user or group does not have read permissions, as enforced by our \ac{SACL}, he cannot rename or move the file to an unprotected folder or filename, ensuring the \emph{confidentiality} of the information stored in the file. In the second case we prevent the protected file from being overwritten by another file, if the permissions are not correct. This way we improve \emph{integrity} of the underlying \ac{OS}, by preventing modification of the protected file. 

\par Finally in the case of \codeft{open()} and \codeft{openat()}, we only have to check for one filename in our \ac{SACL}s. If there is an entry, then the permission check algorithm is more complicated. This happens because we have to match the requested by the process access \codeft{mode} with the permissions we want to enforce. So, we check for read permission when a \codeft{O\_RDONLY} access is requested, and for write permissions on a \codeft{O\_WRONLY}. In the case of a \codeft{O\_RDWR} request we initially check for both permissions. If that fails, we then check if the process user or group has read permissions. If that is true, we alter the file access mode to read-only and allow execution. If all of them fail we change the \codeft{rax} register contents to \codeft{NULL} and resume \ac{VM} execution, which results to a failed system call. This more complex permission check improves confidentiality, by not allowing read access to those who do not have the right, and integrity and availability by denying write access to those who cannot write to the file, as per the \ac{SACL} enforced policy. Figure~\ref{fig:open} shows the code for the permission checks done in case of the \codeft{open()} and \codeft{openat()} system calls.




\begin{figure}[ht!]
\footnotesize {
	{\fontfamily{qcr}\selectfont 
switch(info->regs->rax)\{\\
\tab case S\_OPEN:\\
\tab case S\_OPENAT:\\
\tab if ( ((info->regs->rsi \& 07) | O\_RDONLY) == O\_RDONLY)\{\\
\tab \tab if ( !(check->mode \& r) ) \{\\
\tab \tab \tab vmi\_set\_vcpureg (vmi, 0, RDI, info->vcpu);\\
\tab \tab \tab return 1; \}\\
\tab \} else if ( ((info->regs->rsi \& 07) | O\_WRONLY) == O\_WRONLY) \{\\
\tab \tab if ( !(check->mode \& w) ) \{\\
\tab \tab \tab vmi\_set\_vcpureg (vmi, 0, RDI, info->vcpu);\\
\tab \tab \tab return 1; \}\\
\tab \} else if ( ((info->regs->rsi \& 07) | O\_RDWR) == O\_RDWR) \{\\
\tab \tab if ( !(check->mode \& w) \&\& !(check->mode \& r) ) \{\\
\tab \tab \tab vmi\_set\_vcpureg (vmi, 0, RDI, info->vcpu);\\
\tab \tab \tab return 1;\\
\tab \tab \} else if ( !(check->mode \& w) )\{\\
\tab \tab \tab vmi\_set\_vcpureg(vmi, 0, RSI, info->vcpu);\\
\tab \tab \tab return 1; \}\\
\tab \}\\
\tab break;\\
\}\\
}}
	\caption{open() and openat() permission checks}
	\label{fig:open}
\end{figure}

\par When one of the trapped system calls gets executed, LibVMI pauses the \ac{VM} execution. It then passes the \ac{VM}s state information to DRAKVUF, where our running plugin retrieves it. At this point the guest \ac{OS} is paused and none of its processes continue running, being unable to bypass and alter the \ac{VM}'s state. Going through some \ac{VM} memory accesses, the plugin gets the file being accessed, the \codeft{userid}, and the \codeft{groupid}. With this information, it goes through the \ac{SACL} to find any matching files or folders that are being protected. If none are found, it returns control to LibVMI, which then resumes the \ac{VM}'s execution. If an entry in the \ac{SACL} is found, then the plugin checks if the requested file access is prohibited. If it is allowed, execution continues normally. If it is prohibited, on the other hand, then the plugin changes the value of some registers related to the system call so that it will fail.


\subsection{Monitoring of program execution}

\par In addition to the system calls of table \ref{tbl:syscalls}, we trapped also the \codeft{execve()} and \codeft{execveat()} system calls. Following the same technique, we retrieve the pathname of the program that is requested to be executed. We then check the permissions stored in the \acp{SACL} and decide on allowing execution or not.

\par In addition to checking the \ac{SACL} permissions, to deny execution immediately if the file is not in the \ac{SACL}. This creates an efficient application white-list monitoring tool, that can mitigate a broad variety of viruses and malware in general. The reason for this is that most of the malware will save its code on a file for later use. When it tries to execute this file, since it is not part of the original file-system, execution will cancel. We must note that for a malware to create a persistence mechanism on a compromised system, it must write its code on a file. By write protecting the already present executable files, and denying execution of new files, we mitigate a significant volume of old and new malware, including \emph{zero-day} attacks.



\subsection{Guest \ac{VM} Configuration}\label{sub:conf}

As mentioned before, there is no significant setup for the guest \ac{VM} in order for our system to run. The only requirement coming from LibVMI and DRAKVUF is the creation and export of a Rekall profile in the guest \ac{VM}. Because this profile depends on the kernel version running, it is imperative to recreate the profile in the case of a kernel version update. 

\par To protect the \ac{VM} from running unprotected in such a case, we have set the options in the Xen guest configuration file, which resides on the hypervisor, to shutdown the \ac{VM} in case it needs to reboot, as shown in figure~\ref{fig:conf}. This does not affect significantly the usability of the guest system, as the Linux \ac{OS} seldom requires a reboot, even after software updates. Additionally we trap and deny the \codeft{kexec\_load()} system call, which is used to load a new kernel to be used during the next boot sequence. These two steps protect against custom built kernels, compiled by attackers, since the \ac{VM} will not run unsupervised, and will not allow the loading of a new kernel. The administrator will need to investigate harder to determine why the \ac{VM} was rebooted, or powered off in the first place.

\begin{figure}[ht]
	\centering
	\footnotesize{\fontfamily{qcr}\selectfont 
	\begin{lstlisting}
		on_poweroff = "destroy"
		on_reboot = "destroy"
		on_crash = "destroy"
	\end{lstlisting}}
	\caption{Guest \ac{VM} shutdown configuration line}
	\label{fig:conf}
\end{figure}

\par To support file confidentiality, integrity and availability even from root access, we need to prohibit the root user from executing the \codeft{su} command. This command, short for switch user, allows root to switch to any account in the \ac{OS}. To do that we need to edit a configuration file so that the execution of this command is not allowed. Our test \ac{VM} uses the \ac{PAM}. To achieve the required result, we edited the \codeft{/etc/pam.d/su} file in the guest \ac{OS} by adding the line shown in figure~\ref{fig:pam}, and then denying the write permission of all users for that file in the \ac{SACL} so that it cannot be modified.

\begin{figure}[ht]
	\centering
	\footnotesize{\fontfamily{qcr}\selectfont 
	\begin{lstlisting}
	auth       required   pam_wheel.so deny group=root	
	\end{lstlisting}}
	\caption{Guest \ac{VM} configuration to deny \emph{root} from running \emph{su}}
	\label{fig:pam}
\end{figure}

\par Furthermore, since \codeft{root} can change other user passwords, we also need to deny that capability. To do that, we do not need any special in-\ac{VM} configuration. We just need to protect the \codeft{/etc/shadow} file from being modified by anyone. Therefore, a sample \ac{SACL} to enforce these minimum security requirements we have set, is shown in figure \ref{fig:root_sacl}


\par Concluding, we have seen that we make no alteration at all at the guest \ac{VM}. Concerning usability, the only things we have restricted are the ability of the \codeft{root} user to change the password of any other user, and the capability of the root user to switch to any other user. This can be troublesome in the event that a user has forgotten his password, but we assess it as an acceptable usability limitation.











